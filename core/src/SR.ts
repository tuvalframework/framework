export class SR {

    public static readonly Overflow_TimeSpanTooLong: string = "Overflow_TimeSpanTooLong";
    public static readonly ReducibleMustOverrideReduce: string = "reducible nodes must override Expression.Reduce()";
    public static readonly MustReduceToDifferent: string = "node cannot reduce to itself or null";
    public static readonly ReducedNotCompatible: string = "cannot assign from the reduced node type to the original node type";
    public static readonly SetterHasNoParams: string = "Setter must have parameters.";
    public static readonly PropertyCannotHaveRefType: string = "Property cannot have a managed pointer type.";
    public static readonly IndexesOfSetGetMustMatch: string = "Indexing parameters of getter and setter must match.";
    public static readonly AccessorsCannotHaveVarArgs: string = "Accessor method should not have VarArgs.";
    public static readonly AccessorsCannotHaveByRefArgs: string = "Accessor indexes cannot be passed ByRef.";
    public static readonly BoundsCannotBeLessThanOne: string = "Bounds count cannot be less than 1";
    public static readonly TypeMustNotBeByRef: string = "Type must not be ByRef";
    public static readonly TypeMustNotBePointer: string = "Type must not be a pointer type";
    public static readonly SetterMustBeVoid: string = "Setter should have void type.";
    public static readonly PropertyTypeMustMatchGetter: string = "Property type must match the value type of getter";
    public static readonly PropertyTypeMustMatchSetter: string = "Property type must match the value type of setter";
    public static readonly BothAccessorsMustBeStatic: string = "Both accessors must be static.";
    public static readonly OnlyStaticFieldsHaveNullInstance: string = "Static field requires null instance, non-static field requires non-null instance.";
    public static readonly OnlyStaticPropertiesHaveNullInstance: string = "Static property requires null instance, non-static property requires non-null instance.";
    public static readonly OnlyStaticMethodsHaveNullInstance: string = "Static method requires null instance, non-static method requires non-null instance.";
    public static readonly PropertyTypeCannotBeVoid: string = "Property cannot have a void type.";
    public static readonly InvalidUnboxType: string = "Can only unbox from an object or interface type to a value type.";
    public static readonly ExpressionMustBeWriteable: string = "Expression must be writeable";
    public static readonly ArgumentMustNotHaveValueType: string = "Argument must not have a value type.";
    public static readonly MustBeReducible: string = "must be reducible node";
    public static readonly AllTestValuesMustHaveSameType: string = "All test values must have the same type.";
    public static readonly AllCaseBodiesMustHaveSameType: string = "All case bodies and the default body must have the same type.";
    public static readonly DefaultBodyMustBeSupplied: string = "Default body must be supplied if case bodies are not System.Void.";
    public static readonly LabelMustBeVoidOrHaveExpression: string = "Label type must be System.Void if an expression is not supplied";
    public static readonly LabelTypeMustBeVoid: string = "Type must be System.Void for this label argument";
    public static readonly QuotedExpressionMustBeLambda: string = "Quoted expression must be a lambda";
    public static readonly VariableMustNotBeByRef: string = "Variable '{0}' uses unsupported type '{1}'. Reference types are not supported for variables.";
    public static readonly DuplicateVariable: string = "Found duplicate parameter '{0}'. Each ParameterExpression in the list must be a unique object.";
    public static readonly StartEndMustBeOrdered: string = "Start and End must be well ordered";
    public static readonly FaultCannotHaveCatchOrFinally: string = "fault cannot be used with catch or finally clauses";
    public static readonly TryMustHaveCatchFinallyOrFault: string = "try must have at least one catch, finally, or fault clause";
    public static readonly BodyOfCatchMustHaveSameTypeAsBodyOfTry: string = "Body of catch must have the same type as body of try.";
    public static readonly ExtensionNodeMustOverrideProperty: string = "Extension node must override the property {0}.";
    public static readonly UserDefinedOperatorMustBeStatic: string = "User-defined operator method '{0}' must be static.";
    public static readonly UserDefinedOperatorMustNotBeVoid: string = "User-defined operator method '{0}' must not be void.";
    public static readonly CoercionOperatorNotDefined: string = "No coercion operator is defined between types '{0}' and '{1}'.";
    public static readonly UnaryOperatorNotDefined: string = "The unary operator {0} is not defined for the type '{1}'.";
    public static readonly BinaryOperatorNotDefined: string = "The binary operator {0} is not defined for the types '{1}' and '{2}'.";
    public static readonly ReferenceEqualityNotDefined: string = "Reference equality is not defined for the types '{0}' and '{1}'.";
    public static readonly OperandTypesDoNotMatchParameters: string = "The operands for operator '{0}' do not match the parameters of method '{1}'.";
    public static readonly OverloadOperatorTypeDoesNotMatchConversionType: string = "The return type of overload method for operator '{0}' does not match the parameter type of conversion method '{1}'.";
    public static readonly ConversionIsNotSupportedForArithmeticTypes: string = "Conversion is not supported for arithmetic types without operator overloading.";
    public static readonly ArgumentMustBeArray: string = "Argument must be array";
    public static readonly ArgumentMustBeBoolean: string = "Argument must be boolean";
    public static readonly EqualityMustReturnBoolean: string = "The user-defined equality method '{0}' must return a boolean value.";
    public static readonly ArgumentMustBeFieldInfoOrPropertyInfo: string = "Argument must be either a FieldInfo or PropertyInfo";
    public static readonly ArgumentMustBeFieldInfoOrPropertyInfoOrMethod: string = "Argument must be either a FieldInfo, PropertyInfo or MethodInfo";
    public static readonly ArgumentMustBeInstanceMember: string = "Argument must be an instance member";
    public static readonly ArgumentMustBeInteger: string = "Argument must be of an integer type";
    public static readonly ArgumentMustBeArrayIndexType: string = "Argument for array index must be of type Int32";
    public static readonly ArgumentMustBeSingleDimensionalArrayType: string = "Argument must be single-dimensional, zero-based array type";
    public static readonly ArgumentTypesMustMatch: string = "Argument types do not match";
    public static readonly CannotAutoInitializeValueTypeElementThroughProperty: string = "Cannot auto initialize elements of value type through property '{0}', use assignment instead";
    public static readonly CannotAutoInitializeValueTypeMemberThroughProperty: string = "Cannot auto initialize members of value type through property '{0}', use assignment instead";
    public static readonly IncorrectTypeForTypeAs: string = "The type used in TypeAs Expression must be of reference or nullable type, {0} is neither";
    public static readonly CoalesceUsedOnNonNullType: string = "Coalesce used with type that cannot be null";
    public static readonly ExpressionTypeCannotInitializeArrayType: string = "An expression of type '{0}' cannot be used to initialize an array of type '{1}'";
    public static readonly ArgumentTypeDoesNotMatchMember: string = " Argument type '{0}' does not match the corresponding member type '{1}'";
    public static readonly ArgumentMemberNotDeclOnType: string = " The member '{0}' is not declared on type '{1}' being created";
    public static readonly ExpressionTypeDoesNotMatchReturn: string = "Expression of type '{0}' cannot be used for return type '{1}'";
    public static readonly ExpressionTypeDoesNotMatchAssignment: string = "Expression of type '{0}' cannot be used for assignment to type '{1}'";
    public static readonly ExpressionTypeDoesNotMatchLabel: string = "Expression of type '{0}' cannot be used for label of type '{1}'";
    public static readonly ExpressionTypeNotInvocable: string = "Expression of type '{0}' cannot be invoked";
    public static readonly FieldNotDefinedForType: string = "Field '{0}' is not defined for type '{1}'";
    public static readonly InstanceFieldNotDefinedForType: string = "Instance field '{0}' is not defined for type '{1}'";
    public static readonly FieldInfoNotDefinedForType: string = "Field '{0}.{1}' is not defined for type '{2}'";
    public static readonly IncorrectNumberOfIndexes: string = "Incorrect number of indexes";
    public static readonly IncorrectNumberOfLambdaDeclarationParameters: string = "Incorrect number of parameters supplied for lambda declaration";
    public static readonly IncorrectNumberOfMembersForGivenConstructor: string = " Incorrect number of members for constructor";
    public static readonly IncorrectNumberOfArgumentsForMembers: string = "Incorrect number of arguments for the given members ";
    public static readonly LambdaTypeMustBeDerivedFromSystemDelegate: string = "Lambda type parameter must be derived from System.MulticastDelegate";
    public static readonly MemberNotFieldOrProperty: string = "Member '{0}' not field or property";
    public static readonly MethodContainsGenericParameters: string = "Method {0} contains generic parameters";
    public static readonly MethodIsGeneric: string = "Method {0} is a generic method definition";
    public static readonly MethodNotPropertyAccessor: string = "The method '{0}.{1}' is not a property accessor";
    public static readonly PropertyDoesNotHaveGetter: string = "The property '{0}' has no 'get' accessor";
    public static readonly PropertyDoesNotHaveSetter: string = "The property '{0}' has no 'set' accessor";
    public static readonly PropertyDoesNotHaveAccessor: string = "The property '{0}' has no 'get' or 'set' accessors";
    public static readonly NotAMemberOfType: string = "'{0}' is not a member of type '{1}'";
    public static readonly NotAMemberOfAnyType: string = "'{0}' is not a member of any type";
    public static readonly UnsupportedExpressionType: string = "The expression type '{0}' is not supported";
    public static readonly ParameterExpressionNotValidAsDelegate: string = "ParameterExpression of type '{0}' cannot be used for delegate parameter of type '{1}'";
    public static readonly PropertyNotDefinedForType: string = "Property '{0}' is not defined for type '{1}'";
    public static readonly InstancePropertyNotDefinedForType: string = "Instance property '{0}' is not defined for type '{1}'";
    public static readonly InstancePropertyWithoutParameterNotDefinedForType: string = "Instance property '{0}' that takes no argument is not defined for type '{1}'";
    public static readonly InstancePropertyWithSpecifiedParametersNotDefinedForType: string = "Instance property '{0}{1}' is not defined for type '{2}'";
    public static readonly InstanceAndMethodTypeMismatch: string = "Method '{0}' declared on type '{1}' cannot be called with instance of type '{2}'";
    public static readonly TypeContainsGenericParameters: string = "Type {0} contains generic parameters";
    public static readonly TypeIsGeneric: string = "Type {0} is a generic type definition";
    public static readonly TypeMissingDefaultConstructor: string = "Type '{0}' does not have a default constructor";
    public static readonly ElementInitializerMethodNotAdd: string = "Element initializer method must be named 'Add'";
    public static readonly ElementInitializerMethodNoRefOutParam: string = "Parameter '{0}' of element initializer method '{1}' must not be a pass by reference parameter";
    public static readonly ElementInitializerMethodWithZeroArgs: string = "Element initializer method must have at least 1 parameter";
    public static readonly ElementInitializerMethodStatic: string = "Element initializer method must be an instance method";
    public static readonly TypeNotIEnumerable: string = "Type '{0}' is not IEnumerable";
    public static readonly UnhandledBinary: string = "Unhandled binary: {0}";
    public static readonly UnhandledBinding: string = "Unhandled binding ";
    public static readonly UnhandledBindingType: string = "Unhandled Binding Type: {0}";
    public static readonly UnhandledUnary: string = "Unhandled unary: {0}";
    public static readonly UnknownBindingType: string = "Unknown binding type";
    public static readonly UserDefinedOpMustHaveConsistentTypes: string = "The user-defined operator method '{1}' for operator '{0}' must have identical parameter and return types.";
    public static readonly UserDefinedOpMustHaveValidReturnType: string = "The user-defined operator method '{1}' for operator '{0}' must return the same type as its parameter or a derived type.";
    public static readonly LogicalOperatorMustHaveBooleanOperators: string = "The user-defined operator method '{1}' for operator '{0}' must have associated boolean True and False operators.";
    public static readonly MethodWithArgsDoesNotExistOnType: string = "No method '{0}' on type '{1}' is compatible with the supplied arguments.";
    public static readonly GenericMethodWithArgsDoesNotExistOnType: string = "No generic method '{0}' on type '{1}' is compatible with the supplied type arguments and arguments. No type arguments should be provided if the method is non-generic. ";
    public static readonly MethodWithMoreThanOneMatch: string = "More than one method '{0}' on type '{1}' is compatible with the supplied arguments.";
    public static readonly PropertyWithMoreThanOneMatch: string = "More than one property '{0}' on type '{1}' is compatible with the supplied arguments.";
    public static readonly IncorrectNumberOfTypeArgsForFunc: string = "An incorrect number of type arguments were specified for the declaration of a Func type.";
    public static readonly IncorrectNumberOfTypeArgsForAction: string = "An incorrect number of type arguments were specified for the declaration of an Action type.";
    public static readonly ArgumentCannotBeOfTypeVoid: string = "Argument type cannot be System.Void.";
    public static readonly OutOfRange: string = "{0} must be greater than or equal to {1}";
    public static readonly LabelTargetAlreadyDefined: string = "Cannot redefine label '{0}' in an inner block.";
    public static readonly LabelTargetUndefined: string = "Cannot jump to undefined label '{0}'.";
    public static readonly ControlCannotLeaveFinally: string = "Control cannot leave a finally block.";
    public static readonly ControlCannotLeaveFilterTest: string = "Control cannot leave a filter test.";
    public static readonly AmbiguousJump: string = "Cannot jump to ambiguous label '{0}'.";
    public static readonly ControlCannotEnterTry: string = "Control cannot enter a try block.";
    public static readonly ControlCannotEnterExpression: string = "Control cannot enter an expression--only statements can be jumped into.";
    public static readonly NonLocalJumpWithValue: string = "Cannot jump to non-local label '{0}' with a value. Only jumps to labels defined in outer blocks can pass values.";
    public static readonly CannotCompileConstant: string = "CompileToMethod cannot compile constant '{0}' because it is a non-trivial value, such as a live object. Instead, create an expression tree that can construct this value.";
    public static readonly CannotCompileDynamic: string = "Dynamic expressions are not supported by CompileToMethod. Instead, create an expression tree that uses System.Runtime.CompilerServices.CallSite.";
    public static readonly InvalidLvalue: string = "Invalid lvalue for assignment: {0}.";
    public static readonly UndefinedVariable: string = "variable '{0}' of type '{1}' referenced from scope '{2}', but it is not defined";
    public static readonly CannotCloseOverByRef: string = "Cannot close over byref parameter '{0}' referenced in lambda '{1}'";
    public static readonly UnexpectedVarArgsCall: string = "Unexpected VarArgs call to method '{0}'";
    public static readonly RethrowRequiresCatch: string = "Rethrow statement is valid only inside a Catch block.";
    public static readonly TryNotAllowedInFilter: string = "Try expression is not allowed inside a filter body.";
    public static readonly MustRewriteToSameNode: string = "When called from '{0}', rewriting a node of type '{1}' must return a non-null value of the same type. Alternatively, override '{2}' and change it to not visit children of this type.";
    public static readonly MustRewriteChildToSameType: string = "Rewriting child expression from type '{0}' to type '{1}' is not allowed, because it would change the meaning of the operation. If this is intentional, override '{2}' and change it to allow this rewrite.";
    public static readonly MustRewriteWithoutMethod: string = "Rewritten expression calls operator method '{0}', but the original node had no operator method. If this is intentional, override '{1}' and change it to allow this rewrite.";
    public static readonly InvalidNullValue: string = "The value null is not of type '{0}' and cannot be used in this collection.";
    public static readonly InvalidObjectType: string = "The value '{0}' is not of type '{1}' and cannot be used in this collection.";
    public static readonly TryNotSupportedForMethodsWithRefArgs: string = "TryExpression is not supported as an argument to method '{0}' because it has an argument with by-ref type. Construct the tree so the TryExpression is not nested inside of this expression.";
    public static readonly TryNotSupportedForValueTypeInstances: string = "TryExpression is not supported as a child expression when accessing a member on type '{0}' because it is a value type. Construct the tree so the TryExpression is not nested inside of this expression.";
    public static readonly EnumerationIsDone: string = "Enumeration has either not started or has already finished.";
    public static readonly TestValueTypeDoesNotMatchComparisonMethodParameter: string = "Test value of type '{0}' cannot be used for the comparison method parameter of type '{1}'";
    public static readonly SwitchValueTypeDoesNotMatchComparisonMethodParameter: string = "Switch value of type '{0}' cannot be used for the comparison method parameter of type '{1}'";
    public static readonly PdbGeneratorNeedsExpressionCompiler: string = "DebugInfoGenerator created by CreatePdbGenerator can only be used with LambdaExpression.CompileToMethod.";
    public static readonly InvalidArgumentValue: string = "Invalid argument value";
    public static readonly NonEmptyCollectionRequired: string = "Non-empty collection required";
    public static readonly CollectionModifiedWhileEnumerating: string = "Collection was modified; enumeration operation may not execute.";
    public static readonly ExpressionMustBeReadable: string = "Expression must be readable";
    public static readonly ExpressionTypeDoesNotMatchMethodParameter: string = "Expression of type '{0}' cannot be used for parameter of type '{1}' of method '{2}'";
    public static readonly ExpressionTypeDoesNotMatchParameter: string = "Expression of type '{0}' cannot be used for parameter of type '{1}'";
    public static readonly ExpressionTypeDoesNotMatchConstructorParameter: string = "Expression of type '{0}' cannot be used for constructor parameter of type '{1}'";
    public static readonly IncorrectNumberOfMethodCallArguments: string = "Incorrect number of arguments supplied for call to method '{0}'";
    public static readonly IncorrectNumberOfLambdaArguments: string = "Incorrect number of arguments supplied for lambda invocation";
    public static readonly IncorrectNumberOfConstructorArguments: string = "Incorrect number of arguments for constructor";
    public static readonly NonStaticConstructorRequired: string = "The constructor should not be static";
    public static readonly NonAbstractConstructorRequired: string = "Can't compile a NewExpression with a constructor declared on an abstract class";
    public static readonly FirstArgumentMustBeCallSite: string = "First argument of delegate must be CallSite";
    public static readonly NoOrInvalidRuleProduced: string = "No or Invalid rule produced";
    public static readonly TypeMustBeDerivedFromSystemDelegate: string = "Type must be derived from System.Delegate";
    public static readonly TypeParameterIsNotDelegate: string = "Type parameter is {0}. Expected a delegate.";
    public static readonly ArgumentTypeCannotBeVoid: string = "Argument type cannot be void";
    public static readonly ArgCntMustBeGreaterThanNameCnt: string = "Argument count must be greater than number of named arguments.";
    public static readonly BinderNotCompatibleWithCallSite: string = "The result type '{0}' of the binder '{1}' is not compatible with the result type '{2}' expected by the call site.";
    public static readonly BindingCannotBeNull: string = "Bind cannot return null.";
    public static readonly DynamicBinderResultNotAssignable: string = "The result type '{0}' of the dynamic binding produced by binder '{1}' is not compatible with the result type '{2}' expected by the call site.";
    public static readonly DynamicBindingNeedsRestrictions: string = "The result of the dynamic binding produced by the object with type '{0}' for the binder '{1}' needs at least one restriction.";
    public static readonly DynamicObjectResultNotAssignable: string = "The result type '{0}' of the dynamic binding produced by the object with type '{1}' for the binder '{2}' is not compatible with the result type '{3}' expected by the call site.";
    public static readonly InvalidMetaObjectCreated: string = "An IDynamicMetaObjectProvider {0} created an invalid DynamicMetaObject instance.";
    public static readonly AmbiguousMatchInExpandoObject: string = "More than one key matching '{0}' was found in the ExpandoObject.";
    public static readonly CollectionReadOnly: string = "Collection is read-only.";
    public static readonly KeyDoesNotExistInExpando: string = "The specified key '{0}' does not exist in the ExpandoObject.";
    public static readonly SameKeyExistsInExpando: string = "An element with the same key '{0}' already exists in the ExpandoObject.";
    public static readonly Arg_KeyNotFoundWithKey: string = "The given key '{0}' was not present in the dictionary.";
    public static readonly EmptyEnumerable: string = "Enumeration yielded no results";
    public static readonly MoreThanOneElement: string = "Sequence contains more than one element";
    public static readonly MoreThanOneMatch: string = "Sequence contains more than one matching element";
    public static readonly NoElements: string = "Sequence contains no elements";
    public static readonly NoMatch: string = "Sequence contains no matching element";
    public static readonly ParallelPartitionable_NullReturn: string = "The return value must not be null.";
    public static readonly ParallelPartitionable_IncorretElementCount: string = "The returned array's length must equal the number of partitions requested.";
    public static readonly ParallelPartitionable_NullElement: string = "Elements returned must not be null.";
    public static readonly PLINQ_CommonEnumerator_Current_NotStarted: string = "Enumeration has not started. MoveNext must be called to initiate enumeration.";
    public static readonly PLINQ_ExternalCancellationRequested: string = "The query has been canceled via the token supplied to WithCancellation.";
    public static readonly PLINQ_DisposeRequested: string = "The query enumerator has been disposed.";
    public static readonly ParallelQuery_DuplicateTaskScheduler: string = "The WithTaskScheduler operator may be used at most once in a query.";
    public static readonly ParallelQuery_DuplicateDOP: string = "The WithDegreeOfParallelism operator may be used at most once in a query.";
    public static readonly ParallelQuery_DuplicateExecutionMode: string = "The WithExecutionMode operator may be used at most once in a query.";
    public static readonly PartitionerQueryOperator_NullPartitionList: string = "Partitioner returned null instead of a list of partitions.";
    public static readonly PartitionerQueryOperator_WrongNumberOfPartitions: string = "Partitioner returned a wrong number of partitions.";
    public static readonly PartitionerQueryOperator_NullPartition: string = "Partitioner returned a null partition.";
    public static readonly ParallelQuery_DuplicateWithCancellation: string = "The WithCancellation operator may by used at most once in a query.";
    public static readonly ParallelQuery_DuplicateMergeOptions: string = "The WithMergeOptions operator may be used at most once in a query.";
    public static readonly PLINQ_EnumerationPreviouslyFailed: string = "The query enumerator previously threw an exception.";
    public static readonly ParallelQuery_PartitionerNotOrderable: string = "AsOrdered may not be used with a partitioner that is not orderable.";
    public static readonly ParallelQuery_InvalidAsOrderedCall: string = "AsOrdered may only be called on the result of AsParallel, ParallelEnumerable.Range, or ParallelEnumerable.Repeat.";
    public static readonly ParallelQuery_InvalidNonGenericAsOrderedCall: string = "Non-generic AsOrdered may only be called on the result of the non-generic AsParallel.";
    public static readonly ParallelEnumerable_BinaryOpMustUseAsParallel: string = "The second data source of a binary operator must be of type System.Linq.ParallelQuery<T> rather than System.Collections.Generic.IEnumerable<T>. To fix this problem, use the AsParallel() extension method to convert the right data source to System.Linq.ParallelQuery<T>.";
    public static readonly ParallelEnumerable_WithQueryExecutionMode_InvalidMode: string = "The executionMode argument contains an invalid value.";
    public static readonly ParallelEnumerable_WithMergeOptions_InvalidOptions: string = "The mergeOptions argument contains an invalid value.";
    public static readonly ArgumentNotIEnumerableGeneric: string = "{0} is not IEnumerable<>";
    public static readonly ArgumentNotValid: string = "Argument {0} is not valid";
    public static readonly NoMethodOnType: string = "There is no method '{0}' on type '{1}'";
    public static readonly NoMethodOnTypeMatchingArguments: string = "There is no method '{0}' on type '{1}' that matches the specified arguments";
    public static readonly EnumeratingNullEnumerableExpression: string = "Cannot enumerate a query created from a null IEnumerable<>";
    public static readonly ArgumentOutOfRange_NeedNonNegNum: string = "Non negative number is required.";
    public static readonly ArgumentOutOfRange_NeedValidPipeAccessRights: string = "Invalid PipeAccessRights value.";
    public static readonly Argument_InvalidOffLen: string = "Offset and length were out of bounds for the array or count is greater than the number of elements from index to the end of the source collection.";
    public static readonly Argument_NeedNonemptyPipeName: string = "pipeName cannot be an empty string.";
    public static readonly Argument_NonContainerInvalidAnyFlag: string = "This flag may not be set on a pipe.";
    public static readonly Argument_EmptyServerName: string = "serverName cannot be an empty string.  Use \\\\\\\".\\\\\\\" for current machine.";
    public static readonly Argument_InvalidHandle: string = "Invalid handle.";
    public static readonly ArgumentNull_Buffer: string = "Buffer cannot be null.";
    public static readonly ArgumentNull_ServerName: string = "serverName cannot be null. Use \\\".\\\" for current machine.";
    public static readonly ArgumentOutOfRange_AnonymousReserved: string = "The pipeName \\\"anonymous\\\" is reserved.";
    public static readonly ArgumentOutOfRange_TransmissionModeByteOrMsg: string = "For named pipes, transmission mode can be TransmissionMode.Byte or PipeTransmissionMode.Message. For anonymous pipes, transmission mode can be TransmissionMode.Byte.";
    public static readonly ArgumentOutOfRange_DirectionModeInOutOrInOut: string = "For named pipes, the pipe direction can be PipeDirection.In, PipeDirection.Out or PipeDirection.InOut. For anonymous pipes, the pipe direction can be PipeDirection.In or PipeDirection.Out.";
    public static readonly ArgumentOutOfRange_ImpersonationInvalid: string = "TokenImpersonationLevel.None, TokenImpersonationLevel.Anonymous, TokenImpersonationLevel.Identification, TokenImpersonationLevel.Impersonation or TokenImpersonationLevel.Delegation required.";
    public static readonly ArgumentOutOfRange_OptionsInvalid: string = "options contains an invalid flag.";
    public static readonly ArgumentOutOfRange_HandleInheritabilityNoneOrInheritable: string = "HandleInheritability.None or HandleInheritability.Inheritable required.";
    public static readonly ArgumentOutOfRange_InvalidTimeout: string = "Timeout must be non-negative or equal to -1 (Timeout.Infinite)";
    public static readonly ArgumentOutOfRange_MaxNumServerInstances: string = "maxNumberOfServerInstances must either be a value between 1 and 254, or NamedPipeServerStream.MaxAllowedServerInstances (to obtain the maximum number allowed by system resources).";
    public static readonly ArgumentOutOfRange_NeedPosNum: string = "Positive number required.";
    public static readonly InvalidOperation_PipeNotYetConnected: string = "Pipe hasn't been connected yet.";
    public static readonly InvalidOperation_PipeDisconnected: string = "Pipe is in a disconnected state.";
    public static readonly InvalidOperation_PipeHandleNotSet: string = "Pipe handle has not been set.  Did your PipeStream implementation call InitializeHandle?";
    public static readonly InvalidOperation_PipeNotAsync: string = "Pipe is not opened in asynchronous mode.";
    public static readonly InvalidOperation_PipeReadModeNotMessage: string = "ReadMode is not of PipeTransmissionMode.Message.";
    public static readonly InvalidOperation_PipeAlreadyConnected: string = "Already in a connected state.";
    public static readonly InvalidOperation_PipeAlreadyDisconnected: string = "Already in a disconnected state.";
    public static readonly IO_EOF_ReadBeyondEOF: string = "Unable to read beyond the end of the stream.";
    public static readonly IO_FileNotFound: string = "Unable to find the specified file.";
    public static readonly IO_FileNotFound_FileName: string = "Could not find file '{0}'.";
    public static readonly IO_AlreadyExists_Name: string = "Cannot create \\\"{0}\\\" because a file or directory with the same name already exists.";
    public static readonly IO_FileExists_Name: string = "The file '{0}' already exists.";
    public static readonly IO_IO_PipeBroken: string = "Pipe is broken.";
    public static readonly IO_OperationAborted: string = "IO operation was aborted unexpectedly.";
    public static readonly IO_SharingViolation_File: string = "The process cannot access the file '{0}' because it is being used by another process.";
    public static readonly IO_SharingViolation_NoFileName: string = "The process cannot access the file because it is being used by another process.";
    public static readonly IO_PipeBroken: string = "Pipe is broken.";
    public static readonly IO_InvalidPipeHandle: string = "Invalid pipe handle.";
    public static readonly IO_PathNotFound_Path: string = "Could not find a part of the path '{0}'.";
    public static readonly IO_PathNotFound_NoPathName: string = "Could not find a part of the path.";
    public static readonly IO_PathTooLong: string = "The specified file name or path is too long, or a component of the specified path is too long.";
    public static readonly NotSupported_UnreadableStream: string = "Stream does not support reading.";
    public static readonly NotSupported_UnseekableStream: string = "Stream does not support seeking.";
    public static readonly NotSupported_UnwritableStream: string = "Stream does not support writing.";
    public static readonly NotSupported_AnonymousPipeUnidirectional: string = "Anonymous pipes can only be in one direction.";
    public static readonly NotSupported_AnonymousPipeMessagesNotSupported: string = "Anonymous pipes do not support PipeTransmissionMode.Message ReadMode.";
    public static readonly ObjectDisposed_PipeClosed: string = "Cannot access a closed pipe.";
    public static readonly UnauthorizedAccess_IODenied_Path: string = "Access to the path '{0}' is denied.";
    public static readonly UnauthorizedAccess_IODenied_NoPathName: string = "Access to the path is denied.";
    public static readonly ArgumentOutOfRange_FileLengthTooBig: string = "Specified file length was too large for the file system.";
    public static readonly PlatformNotSupported_MessageTransmissionMode: string = "Message transmission mode is not supported on this platform.";
    public static readonly PlatformNotSupported_RemotePipes: string = "Access to remote named pipes is not supported on this platform.";
    public static readonly PlatformNotSupported_InvalidPipeNameChars: string = "The name of a pipe on this platform must be a valid file name or a valid absolute path to a file name.";
    public static readonly ObjectDisposed_StreamClosed: string = "Cannot access a closed Stream.";
    public static readonly PlatformNotSupported_OperatingSystemError: string = "The operating system returned error '{0}' indicating that the operation is not supported.";
    public static readonly IO_AllPipeInstancesAreBusy: string = "All pipe instances are busy.";
    public static readonly IO_PathTooLong_Path: string = "The path '{0}' is too long, or a component of the specified path is too long.";
    public static readonly UnauthorizedAccess_NotOwnedByCurrentUser: string = "Could not connect to the pipe because it was not owned by the current user.";
    public static readonly UnauthorizedAccess_ClientIsNotCurrentUser: string = "Client connection (user id {0}) was refused because it was not owned by the current user (id {1}).";
    public static readonly net_invalidversion: string = "This protocol version is not supported.";
    public static readonly net_noseek: string = "This stream does not support seek operations.";
    public static readonly net_invasync: string = "Cannot block a call on this socket while an earlier asynchronous call is in progress.";
    public static readonly net_io_timeout_use_gt_zero: string = "Timeout can be only be set to 'System.Threading.Timeout.Infinite' or a value > 0.";
    public static readonly net_notconnected: string = "The operation is not allowed on non-connected sockets.";
    public static readonly net_notstream: string = "The operation is not allowed on non-stream oriented sockets.";
    public static readonly net_stopped: string = "Not listening. You must call the Start() method before calling this method.";
    public static readonly net_udpconnected: string = "Cannot send packets to an arbitrary host while connected.";
    public static readonly net_readonlystream: string = "The stream does not support writing.";
    public static readonly net_writeonlystream: string = "The stream does not support reading.";
    public static readonly net_InvalidAddressFamily: string = "The AddressFamily {0} is not valid for the {1} end point, use {2} instead.";
    public static readonly net_InvalidEndPointAddressFamily: string = "The supplied EndPoint of AddressFamily {0} is not valid for this Socket, use {1} instead.";
    public static readonly net_InvalidSocketAddressSize: string = "The supplied {0} is an invalid size for the {1} end point.";
    public static readonly net_invalidAddressList: string = "None of the discovered or specified addresses match the socket address family.";
    public static readonly net_completed_result: string = "This operation cannot be performed on a completed asynchronous result object.";
    public static readonly net_protocol_invalid_family: string = "'{0}' Client can only accept InterNetwork or InterNetworkV6 addresses.";
    public static readonly net_protocol_invalid_multicast_family: string = "Multicast family is not the same as the family of the '{0}' Client.";
    public static readonly net_sockets_zerolist: string = "The parameter {0} must contain one or more elements.";
    public static readonly net_sockets_blocking: string = "The operation is not allowed on a non-blocking Socket.";
    public static readonly net_sockets_useblocking: string = "Use the Blocking property to change the status of the Socket.";
    public static readonly net_sockets_select: string = "The operation is not allowed on objects of type {0}. Use only objects of type {1}.";
    public static readonly net_sockets_toolarge_select: string = "The {0} list contains too many items; a maximum of {1} is allowed.";
    public static readonly net_sockets_empty_select: string = "All lists are either null or empty.";
    public static readonly net_sockets_mustbind: string = "You must call the Bind method before performing this operation.";
    public static readonly net_sockets_mustlisten: string = "You must call the Listen method before performing this operation.";
    public static readonly net_sockets_mustnotlisten: string = "You may not perform this operation after calling the Listen method.";
    public static readonly net_sockets_mustnotbebound: string = "The socket must not be bound or connected.";
    public static readonly net_sockets_namedmustnotbebound: string = "{0}: The socket must not be bound or connected.";
    public static readonly net_sockets_invalid_ipaddress_length: string = "The number of specified IP addresses has to be greater than 0.";
    public static readonly net_sockets_invalid_optionValue: string = "The specified value is not a valid '{0}'.";
    public static readonly net_sockets_invalid_optionValue_all: string = "The specified value is not valid.";
    public static readonly net_sockets_invalid_dnsendpoint: string = "The parameter {0} must not be of type DnsEndPoint.";
    public static readonly net_sockets_disconnectedConnect: string = "Once the socket has been disconnected, you can only reconnect again asynchronously, and only to a different EndPoint.  BeginConnect must be called on a thread that won't exit until the operation has been completed.";
    public static readonly net_sockets_disconnectedAccept: string = "Once the socket has been disconnected, you can only accept again asynchronously.  BeginAccept must be called on a thread that won't exit until the operation has been completed.";
    public static readonly net_tcplistener_mustbestopped: string = "The TcpListener must not be listening before performing this operation.";
    public static readonly net_socketopinprogress: string = "An asynchronous socket operation is already in progress using this SocketAsyncEventArgs instance.";
    public static readonly net_buffercounttoosmall: string = "The Buffer space specified by the Count property is insufficient for the AcceptAsync method.";
    public static readonly net_multibuffernotsupported: string = "Multiple buffers cannot be used with this method.";
    public static readonly net_ambiguousbuffers: string = "Buffer and BufferList properties cannot both be non-null.";
    public static readonly net_io_writefailure: string = "Unable to write data to the transport connection: {0}.";
    public static readonly net_io_readfailure: string = "Unable to read data from the transport connection: {0}.";
    public static readonly net_io_invalidasyncresult: string = "The IAsyncResult object was not returned from the corresponding asynchronous method on this class.";
    public static readonly net_io_invalidendcall: string = "{0} can only be called once for each asynchronous operation.";
    public static readonly net_value_cannot_be_negative: string = "The specified value cannot be negative.";
    public static readonly ArgumentOutOfRange_Bounds_Lower_Upper: string = "Argument must be between {0} and {1}.";
    public static readonly net_sockets_connect_multiconnect_notsupported: string = "Sockets on this platform are invalid for use after a failed connection attempt.";
    public static readonly net_sockets_dualmode_receivefrom_notsupported: string = "This platform does not support packet information for dual-mode sockets.  If packet information is not required, use Socket.Receive.  If packet information is required set Socket.DualMode to false.";
    public static readonly net_sockets_accept_receive_notsupported: string = "This platform does not support receiving data with Socket.AcceptAsync.  Instead, make a separate call to Socket.ReceiveAsync.";
    public static readonly net_sockets_duplicateandclose_notsupported: string = "This platform does not support Socket.DuplicateAndClose.  Instead, create a new socket.";
    public static readonly net_sockets_transmitfileoptions_notsupported: string = "This platform does not support TransmitFileOptions other than TransmitFileOptions.UseDefaultWorkerThread.";
    public static readonly ArgumentOutOfRange_PathLengthInvalid: string = "The path '{0}' is of an invalid length for use with domain sockets on this platform.  The length must be between 1 and {1} characters, inclusive.";
    public static readonly net_io_readwritefailure: string = "Unable to transfer data on the transport connection: {0}.";
    public static readonly PlatformNotSupported_AcceptSocket: string = "Accepting into an existing Socket is not supported on this platform.";
    public static readonly PlatformNotSupported_IOControl: string = "Socket.IOControl handles Windows-specific control codes and is not supported on this platform.";
    public static readonly PlatformNotSupported_IPProtectionLevel: string = "IP protection level cannot be controlled on this platform.";
    public static readonly InvalidOperation_BufferNotExplicitArray: string = "This operation may only be performed when the buffer was set using the SetBuffer overload that accepts an array.";
    public static readonly InvalidOperation_IncorrectToken: string = "The result of the operation was already consumed and may not be used again.";
    public static readonly InvalidOperation_MultipleContinuations: string = "Another continuation was already registered.";
    public static readonly Argument_InvalidOidValue: string = "The OID value was invalid.";
    public static readonly Argument_InvalidValue: string = "Value was invalid.";
    public static readonly Arg_CryptographyException: string = "Error occurred during a cryptographic operation.";
    public static readonly Cryptography_ArgECDHKeySizeMismatch: string = "The keys from both parties must be the same size to generate a secret agreement.";
    public static readonly Cryptography_ArgECDHRequiresECDHKey: string = "Keys used with the ECDiffieHellmanCng algorithm must have an algorithm group of ECDiffieHellman.";
    public static readonly Cryptography_TlsRequiresLabelAndSeed: string = "The TLS key derivation function requires both the label and seed properties to be set.";
    public static readonly Cryptography_TlsRequires64ByteSeed: string = "The TLS key derivation function requires a seed value of exactly 64 bytes.";
    public static readonly Cryptography_BadHashSize_ForAlgorithm: string = "The provided value of {0} bytes does not match the expected size of {1} bytes for the algorithm ({2}).";
    public static readonly Cryptography_Config_EncodedOIDError: string = "Encoded OID length is too large (greater than 0x7f bytes).";
    public static readonly Cryptography_CSP_NoPrivateKey: string = "Object contains only the public half of a key pair. A private key must also be provided.";
    public static readonly Cryptography_Der_Invalid_Encoding: string = "ASN1 corrupted data.";
    public static readonly Cryptography_DSA_KeyGenNotSupported: string = "DSA keys can be imported, but new key generation is not supported on this platform.";
    public static readonly Cryptography_Encryption_MessageTooLong: string = "The message exceeds the maximum allowable length for the chosen options ({0}).";
    public static readonly Cryptography_ECXmlSerializationFormatRequired: string = "XML serialization of an elliptic curve key requires using an overload which specifies the XML format to be used.";
    public static readonly Cryptography_ECC_NamedCurvesOnly: string = "Only named curves are supported on this platform.";
    public static readonly Cryptography_HashAlgorithmNameNullOrEmpty: string = "The hash algorithm name cannot be null or empty.";
    public static readonly Cryptography_InvalidOID: string = "Object identifier (OID) is unknown.";
    public static readonly Cryptography_CurveNotSupported: string = "The specified curve '{0}' or its parameters are not valid for this platform.";
    public static readonly Cryptography_InvalidCurveOid: string = "The specified Oid is not valid. The Oid.FriendlyName or Oid.Value property must be set.";
    public static readonly Cryptography_InvalidCurveKeyParameters: string = "The specified key parameters are not valid. Q.X and Q.Y are required fields. Q.X, Q.Y must be the same length. If D is specified it must be the same length as Q.X and Q.Y for named curves or the same length as Order for explicit curves.";
    public static readonly Cryptography_InvalidDsaParameters_MissingFields: string = "The specified DSA parameters are not valid; P, Q, G and Y are all required.";
    public static readonly Cryptography_InvalidDsaParameters_MismatchedPGY: string = "The specified DSA parameters are not valid; P, G and Y must be the same length (the key size).";
    public static readonly Cryptography_InvalidDsaParameters_MismatchedQX: string = "The specified DSA parameters are not valid; Q and X (if present) must be the same length.";
    public static readonly Cryptography_InvalidDsaParameters_MismatchedPJ: string = "The specified DSA parameters are not valid; J (if present) must be shorter than P.";
    public static readonly Cryptography_InvalidDsaParameters_SeedRestriction_ShortKey: string = "The specified DSA parameters are not valid; Seed, if present, must be 20 bytes long for keys shorter than 1024 bits.";
    public static readonly Cryptography_InvalidDsaParameters_QRestriction_ShortKey: string = "The specified DSA parameters are not valid; Q must be 20 bytes long for keys shorter than 1024 bits.";
    public static readonly Cryptography_InvalidDsaParameters_QRestriction_LargeKey: string = "The specified DSA parameters are not valid; Q's length must be one of 20, 32 or 64 bytes.";
    public static readonly Cryptography_InvalidECCharacteristic2Curve: string = "The specified Characteristic2 curve parameters are not valid. Polynomial, A, B, G.X, G.Y, and Order are required. A, B, G.X, G.Y must be the same length, and the same length as Q.X, Q.Y and D if those are specified. Seed, Cofactor and Hash are optional. Other parameters are not allowed.";
    public static readonly Cryptography_InvalidECPrimeCurve: string = "The specified prime curve parameters are not valid. Prime, A, B, G.X, G.Y and Order are required and must be the same length, and the same length as Q.X, Q.Y and D if those are specified. Seed, Cofactor and Hash are optional. Other parameters are not allowed.";
    public static readonly Cryptography_InvalidECNamedCurve: string = "The specified named curve parameters are not valid. Only the Oid parameter must be set.";
    public static readonly Cryptography_InvalidKeySize: string = "Specified key is not a valid size for this algorithm.";
    public static readonly Cryptography_InvalidKey_SemiWeak: string = "Specified key is a known semi-weak key for '{0}' and cannot be used.";
    public static readonly Cryptography_InvalidKey_Weak: string = "Specified key is a known weak key for '{0}' and cannot be used.";
    public static readonly Cryptography_InvalidIVSize: string = "Specified initialization vector (IV) does not match the block size for this algorithm.";
    public static readonly Cryptography_InvalidOperation: string = "This operation is not supported for this class.";
    public static readonly Cryptography_InvalidPadding: string = "Padding is invalid and cannot be removed.";
    public static readonly Cryptography_InvalidRsaParameters: string = "The specified RSA parameters are not valid; both Exponent and Modulus are required fields.";
    public static readonly Cryptography_InvalidPaddingMode: string = "Specified padding mode is not valid for this algorithm.";
    public static readonly Cryptography_Invalid_IA5String: string = "The string contains a character not in the 7 bit ASCII character set.";
    public static readonly Cryptography_KeyTooSmall: string = "The key is too small for the requested operation.";
    public static readonly Cryptography_MissingIV: string = "The cipher mode specified requires that an initialization vector (IV) be used.";
    public static readonly Cryptography_MissingKey: string = "No asymmetric key object has been associated with this formatter object.";
    public static readonly Cryptography_MissingOID: string = "Required object identifier (OID) cannot be found.";
    public static readonly Cryptography_MustTransformWholeBlock: string = "TransformBlock may only process bytes in block sized increments.";
    public static readonly Cryptography_NotValidPrivateKey: string = "Key is not a valid private key.";
    public static readonly Cryptography_NotValidPublicOrPrivateKey: string = "Key is not a valid public or private key.";
    public static readonly Cryptography_OAEP_Decryption_Failed: string = "Error occurred while decoding OAEP padding.";
    public static readonly Cryptography_OpenInvalidHandle: string = "Cannot open an invalid handle.";
    public static readonly Cryptography_PartialBlock: string = "The input data is not a complete block.";
    public static readonly Cryptography_PasswordDerivedBytes_FewBytesSalt: string = "Salt is not at least eight bytes.";
    public static readonly Cryptography_RC2_EKS40: string = "EffectiveKeySize value must be at least 40 bits.";
    public static readonly Cryptography_RC2_EKSKS: string = "KeySize value must be at least as large as the EffectiveKeySize value.";
    public static readonly Cryptography_RC2_EKSKS2: string = "EffectiveKeySize must be the same as KeySize in this implementation.";
    public static readonly Cryptography_Rijndael_BlockSize: string = "BlockSize must be 128 in this implementation.";
    public static readonly Cryptography_RSA_DecryptWrongSize: string = "The length of the data to decrypt is not valid for the size of this key.";
    public static readonly Cryptography_SignHash_WrongSize: string = "The provided hash value is not the expected size for the specified hash algorithm.";
    public static readonly Cryptography_TransformBeyondEndOfBuffer: string = "Attempt to transform beyond end of buffer.";
    public static readonly Cryptography_CipherModeNotSupported: string = "The specified CipherMode '{0}' is not supported.";
    public static readonly Cryptography_UnknownHashAlgorithm: string = "'{0}' is not a known hash algorithm.";
    public static readonly Cryptography_UnknownPaddingMode: string = "Unknown padding mode used.";
    public static readonly Cryptography_UnexpectedTransformTruncation: string = "CNG provider unexpectedly terminated encryption or decryption prematurely.";
    public static readonly Cryptography_Unmapped_System_Typed_Error: string = "The system cryptographic library returned error '{0}' of type '{1}'";
    public static readonly Cryptography_UnsupportedPaddingMode: string = "The specified PaddingMode is not supported.";
    public static readonly NotSupported_Method: string = "Method not supported.";
    public static readonly NotSupported_SubclassOverride: string = "Method not supported. Derived class must override.";
    public static readonly Cryptography_AlgorithmTypesMustBeVisible: string = "Algorithms added to CryptoConfig must be accessable from outside their assembly.";
    public static readonly Cryptography_AddNullOrEmptyName: string = "CryptoConfig cannot add a mapping for a null or empty name.";
    public static readonly Argument_Invalid_SafeHandleInvalidOrClosed: string = "The method cannot be called with an invalid or closed SafeHandle.";
    public static readonly Cryptography_ArgExpectedECDiffieHellmanCngPublicKey: string = "DeriveKeyMaterial requires an ECDiffieHellmanCngPublicKey.";
    public static readonly Cryptography_ArgDSARequiresDSAKey: string = "Keys used with the DSACng algorithm must have an algorithm group of DSA.";
    public static readonly Cryptography_ArgECDsaRequiresECDsaKey: string = "Keys used with the ECDsaCng algorithm must have an algorithm group of ECDsa.";
    public static readonly Cryptography_ArgRSARequiresRSAKey: string = "Keys used with the RSACng algorithm must have an algorithm group of RSA.";
    public static readonly Cryptography_CngKeyWrongAlgorithm: string = "This key is for algorithm '{0}'. Expected '{1}'.";
    public static readonly Cryptography_InvalidAlgorithmGroup: string = "The algorithm group '{0}' is invalid.";
    public static readonly Cryptography_InvalidAlgorithmName: string = "The algorithm name '{0}' is invalid.";
    public static readonly Cryptography_InvalidCipherMode: string = "Specified cipher mode is not valid for this algorithm.";
    public static readonly Cryptography_InvalidKeyBlobFormat: string = "The key blob format '{0}' is invalid.";
    public static readonly Cryptography_InvalidProviderName: string = "The provider name '{0}' is invalid.";
    public static readonly Cryptography_KeyBlobParsingError: string = "Key Blob not in expected format.";
    public static readonly Cryptography_OpenEphemeralKeyHandleWithoutEphemeralFlag: string = "The CNG key handle being opened was detected to be ephemeral, but the EphemeralKey open option was not specified.";
    public static readonly Cryptography_WeakKey: string = "Specified key is a known weak key for this algorithm and cannot be used.";
    public static readonly PlatformNotSupported_CryptographyCng: string = "Windows Cryptography Next Generation (CNG) is not supported on this platform.";
    public static readonly CountdownEvent_Increment_AlreadyZero: string = "The event is already signaled and cannot be incremented.";
    public static readonly CountdownEvent_Increment_AlreadyMax: string = "The increment operation would cause the CurrentCount to overflow.";
    public static readonly CountdownEvent_Decrement_BelowZero: string = "Invalid attempt made to decrement the event's count below zero.";
    public static readonly Common_OperationCanceled: string = "The operation was canceled.";
    public static readonly Barrier_Dispose: string = "The barrier has been disposed.";
    public static readonly Barrier_SignalAndWait_InvalidOperation_ZeroTotal: string = "The barrier has no registered participants.";
    public static readonly Barrier_SignalAndWait_ArgumentOutOfRange: string = "The specified timeout must represent a value between -1 and Int32.MaxValue, inclusive.";
    public static readonly Barrier_RemoveParticipants_InvalidOperation: string = "The participantCount argument is greater than the number of participants that haven't yet arrived at the barrier in this phase.";
    public static readonly Barrier_RemoveParticipants_ArgumentOutOfRange: string = "The participantCount argument must be less than or equal the number of participants.";
    public static readonly Barrier_RemoveParticipants_NonPositive_ArgumentOutOfRange: string = "The participantCount argument must be a positive value.";
    public static readonly Barrier_InvalidOperation_CalledFromPHA: string = "This method may not be called from within the postPhaseAction.";
    public static readonly Barrier_AddParticipants_NonPositive_ArgumentOutOfRange: string = "The participantCount argument must be a positive value.";
    public static readonly Barrier_SignalAndWait_InvalidOperation_ThreadsExceeded: string = "The number of threads using the barrier exceeded the total number of registered participants.";
    public static readonly BarrierPostPhaseException: string = "The postPhaseAction failed with an exception.";
    public static readonly Barrier_ctor_ArgumentOutOfRange: string = "The participantCount argument must be non-negative and less than or equal to 32767.";
    public static readonly Barrier_AddParticipants_Overflow_ArgumentOutOfRange: string = "Adding participantCount participants would result in the number of participants exceeding the maximum number allowed.";
    public static readonly SynchronizationLockException_IncorrectDispose: string = "The lock is being disposed while still being used. It either is being held by a thread and/or has active waiters waiting to acquire the lock.";
    public static readonly SynchronizationLockException_MisMatchedWrite: string = "The write lock is being released without being held.";
    public static readonly LockRecursionException_UpgradeAfterReadNotAllowed: string = "Upgradeable lock may not be acquired with read lock held.";
    public static readonly LockRecursionException_UpgradeAfterWriteNotAllowed: string = "Upgradeable lock may not be acquired with write lock held in this mode. Acquiring Upgradeable lock gives the ability to read along with an option to upgrade to a writer.";
    public static readonly SynchronizationLockException_MisMatchedUpgrade: string = "The upgradeable lock is being released without being held.";
    public static readonly SynchronizationLockException_MisMatchedRead: string = "The read lock is being released without being held.";
    public static readonly LockRecursionException_WriteAfterReadNotAllowed: string = "Write lock may not be acquired with read lock held. This pattern is prone to deadlocks. Please ensure that read locks are released before taking a write lock. If an upgrade is necessary, use an upgrade lock in place of the read lock.";
    public static readonly LockRecursionException_RecursiveWriteNotAllowed: string = "Recursive write lock acquisitions not allowed in this mode.";
    public static readonly LockRecursionException_ReadAfterWriteNotAllowed: string = "A read lock may not be acquired with the write lock held in this mode.";
    public static readonly LockRecursionException_RecursiveUpgradeNotAllowed: string = "Recursive upgradeable lock acquisitions not allowed in this mode.";
    public static readonly LockRecursionException_RecursiveReadNotAllowed: string = "Recursive read lock acquisitions not allowed in this mode.";
    public static readonly Overflow_UInt16: string = "Value was either too large or too small for a UInt16.";
    public static readonly ReaderWriterLock_Timeout: string = "The operation has timed out. {0}";
    public static readonly ArgumentOutOfRange_TimeoutMilliseconds: string = "Timeout value in milliseconds must be nonnegative and less than or equal to Int32.MaxValue, or -1 for an infinite timeout.";
    public static readonly ReaderWriterLock_NotOwner: string = "Attempt to release a lock that is not owned by the calling thread. {0}";
    public static readonly ExceptionFromHResult: string = "(Exception from HRESULT: 0x{0:X})";
    public static readonly ReaderWriterLock_InvalidLockCookie: string = "The specified lock cookie is invalid for this operation. {0}";
    public static readonly ReaderWriterLock_RestoreLockWithOwnedLocks: string = "ReaderWriterLock.RestoreLock was called without releasing all locks acquired since the call to ReleaseLock.";
    public static readonly HostExecutionContextManager_InvalidOperation_NotNewCaptureContext: string = "Cannot apply a context that has been marshaled across AppDomains, that was not acquired through a Capture operation or that has already been the argument to a Set call.";
    public static readonly HostExecutionContextManager_InvalidOperation_CannotOverrideSetWithoutRevert: string = "Must override both HostExecutionContextManager.SetHostExecutionContext and HostExecutionContextManager.Revert.";
    public static readonly HostExecutionContextManager_InvalidOperation_CannotUseSwitcherOtherThread: string = "Undo operation must be performed on the thread where the corresponding context was Set.";
    public static readonly Arg_NonZeroLowerBound: string = "The lower bound of target array must be zero.";
    public static readonly Arg_WrongType: string = "The value '{0}' is not of type '{1}' and cannot be used in this generic collection.";
    public static readonly Arg_ArrayPlusOffTooSmall: string = "Destination array is not long enough to copy all the items in the collection. Check array index and length.";
    public static readonly ArgumentOutOfRange_SmallCapacity: string = "capacity was less than the current size.";
    public static readonly Argument_AddingDuplicate: string = "An item with the same key has already been added. Key: {0}";
    public static readonly InvalidOperation_ConcurrentOperationsNotSupported: string = "Operations that change non-concurrent collections must have exclusive access. A concurrent update was performed on this collection and corrupted its state. The collection's state is no longer correct.";
    public static readonly InvalidOperation_EmptyQueue: string = "Queue empty.";
    public static readonly InvalidOperation_EnumOpCantHappen: string = "Enumeration has either not started or has already finished.";
    public static readonly InvalidOperation_EnumFailedVersion: string = "Collection was modified; enumeration operation may not execute.";
    public static readonly InvalidOperation_EmptyStack: string = "Stack empty.";
    public static readonly InvalidOperation_EnumNotStarted: string = "Enumeration has not started. Call MoveNext.";
    public static readonly InvalidOperation_EnumEnded: string = "Enumeration already finished.";
    public static readonly NotSupported_KeyCollectionSet: string = "Mutating a key collection derived from a dictionary is not allowed.";
    public static readonly NotSupported_ValueCollectionSet: string = "Mutating a value collection derived from a dictionary is not allowed.";
    public static readonly Arg_ArrayLengthsDiffer: string = "Array lengths must be the same.";
    public static readonly Arg_BitArrayTypeUnsupported: string = "Only supported array types for CopyTo on BitArrays are Boolean[], Int32[] and Byte[].";
    public static readonly Arg_HSCapacityOverflow: string = "HashSet capacity is too big.";
    public static readonly Arg_HTCapacityOverflow: string = "Hashtable's capacity overflowed and went negative. Check load factor, capacity and the current size of the table.";
    public static readonly Arg_InsufficientSpace: string = "Insufficient space in the target location to copy the information.";
    public static readonly Arg_RankMultiDimNotSupported: string = "Only single dimensional arrays are supported for the requested action.";
    public static readonly Argument_ArrayTooLarge: string = "The input array length must not exceed Int32.MaxValue / {0}. Otherwise BitArray.Length would exceed Int32.MaxValue.";
    public static readonly Argument_InvalidArrayType: string = "Target array type is not compatible with the type of items in the collection.";
    public static readonly ArgumentOutOfRange_BiggerThanCollection: string = "Must be less than or equal to the size of the collection.";
    public static readonly ArgumentOutOfRange_Index: string = "Index was out of range. Must be non-negative and less than the size of the collection.";
    public static readonly ExternalLinkedListNode: string = "The LinkedList node does not belong to current LinkedList.";
    public static readonly LinkedListEmpty: string = "The LinkedList is empty.";
    public static readonly LinkedListNodeIsAttached: string = "The LinkedList node already belongs to a LinkedList.";
    public static readonly NotSupported_SortedListNestedWrite: string = "This operation is not supported on SortedList nested types because they require modifying the original SortedList.";
    public static readonly SortedSet_LowerValueGreaterThanUpperValue: string = "Must be less than or equal to upperValue.";
    public static readonly Serialization_InvalidOnDeser: string = "OnDeserialization method was called while the object was not being deserialized.";
    public static readonly Serialization_MismatchedCount: string = "The serialized Count information doesn't match the number of items.";
    public static readonly Serialization_MissingKeys: string = "The keys for this dictionary are missing.";
    public static readonly Serialization_MissingValues: string = "The values for this dictionary are missing.";
    public static readonly Argument_MapNameEmptyString: string = "Map name cannot be an empty string.";
    public static readonly Argument_EmptyFile: string = "A positive capacity must be specified for a Memory Mapped File backed by an empty file.";
    public static readonly Argument_NewMMFWriteAccessNotAllowed: string = "MemoryMappedFileAccess.Write is not permitted when creating new memory mapped files. Use MemoryMappedFileAccess.ReadWrite instead.";
    public static readonly Argument_ReadAccessWithLargeCapacity: string = "When specifying MemoryMappedFileAccess.Read access, the capacity must not be larger than the file size.";
    public static readonly Argument_NewMMFAppendModeNotAllowed: string = "FileMode.Append is not permitted when creating new memory mapped files. Instead, use MemoryMappedFileView to ensure write-only access within a specified region.";
    public static readonly Argument_NewMMFTruncateModeNotAllowed: string = "FileMode.Truncate is not permitted when creating new memory mapped files.";
    public static readonly ArgumentNull_MapName: string = "Map name cannot be null.";
    public static readonly ArgumentNull_FileStream: string = "fileStream cannot be null.";
    public static readonly ArgumentOutOfRange_CapacityLargerThanLogicalAddressSpaceNotAllowed: string = "The capacity cannot be greater than the size of the system's logical address space.";
    public static readonly ArgumentOutOfRange_NeedPositiveNumber: string = "A positive number is required.";
    public static readonly ArgumentOutOfRange_PositiveOrDefaultCapacityRequired: string = "The capacity must be greater than or equal to 0. 0 represents the size of the file being mapped.";
    public static readonly ArgumentOutOfRange_PositiveOrDefaultSizeRequired: string = "The size must be greater than or equal to 0. If 0 is specified, the view extends from the specified offset to the end of the file mapping.";
    public static readonly ArgumentOutOfRange_CapacityGEFileSizeRequired: string = "The capacity may not be smaller than the file size.";
    public static readonly IO_NotEnoughMemory: string = "Not enough memory to map view.";
    public static readonly InvalidOperation_CantCreateFileMapping: string = "Cannot create file mapping.";
    public static readonly NotSupported_MMViewStreamsFixedLength: string = "MemoryMappedViewStreams are fixed length.";
    public static readonly ObjectDisposed_ViewAccessorClosed: string = "Cannot access a closed accessor.";
    public static readonly ObjectDisposed_StreamIsClosed: string = "Cannot access a closed Stream.";
    public static readonly PlatformNotSupported_NamedMaps: string = "Named maps are not supported.";
    public static readonly Arg_InvalidBase: string = "Arg_InvalidBase";
    public static readonly Format_EmptyInputString: string = "Format_EmptyInputString";
    public static readonly Arg_CannotHaveNegativeValue: string = "Arg_CannotHaveNegativeValue";
    public static readonly Overflow_NegativeUnsigned: string = "Overflow_NegativeUnsigned";
    public static readonly Format_NoParsibleDigits: string = "Format_NoParsibleDigits";
    public static readonly Format_ExtraJunkAtEnd: string = "Format_ExtraJunkAtEnd";
    public static readonly Arg_CannotBeNaN: string = "Arg_CannotBeNaN";
    public static readonly IndexOutOfRange: string = "IndexOutOfRange";
    public static GetString(value: string, index?:number): string {
        return value;
    }


}